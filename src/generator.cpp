#include "nlohmann/json.hpp"
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

std::string build_inheritance_string(const nlohmann::json &meta_meta_schema) {
  if (!meta_meta_schema.contains("base_classes")) {
    return "";
  }
  std::string inheritance_str = " : ";
  bool first = true;
  for (const auto &base : meta_meta_schema["base_classes"]) {
    if (!first) {
      inheritance_str += ", ";
    }
    inheritance_str += "public " + base.get<std::string>();
    first = false;
  }
  return inheritance_str;
}

std::string get_default_value(const std::string &cpp_type) {
  if (cpp_type == "std::string")
    return "\"\"";
  if (cpp_type == "int" || cpp_type == "uint64_t")
    return "0";
  if (cpp_type == "bool")
    return "false";
  // For complex types like std::vector, return a properly typed empty
  // initializer
  if (cpp_type.rfind("std::vector", 0) == 0) {
    return cpp_type + "{}";
  }
  return "{}"; // Default for other types
}

int main(int argc, char *argv[]) {
  if (argc != 3) {
    std::cerr << "Usage: " << argv[0] << " <input_json> <output_header>"
              << std::endl;
    return 1;
  }

  std::string input_path = argv[1];
  std::string output_path = argv[2];

  std::ifstream input_file(input_path);
  if (!input_file.is_open()) {
    std::cerr << "Error: Could not open input file " << input_path << std::endl;
    return 1;
  }

  nlohmann::json meta_schema;
  input_file >> meta_schema;

  std::string kind = meta_schema.value("kind", "struct");
  std::string struct_name = meta_schema.at("struct_name").get<std::string>();
  std::string cpp_namespace =
      meta_schema.at("cpp_namespace").get<std::string>();
  bool is_final = meta_schema.value("is_final", false);

  std::ofstream out_file(output_path);

  // --- File Generation (mostly unchanged) ---
  out_file << "// AUTOGENERATED FILE - DO NOT EDIT\n\n";
  out_file << "#pragma once\n\n";

  for (const auto &header : meta_schema.at("include_headers")) {
    out_file << "#include \"" << header.get<std::string>() << "\"\n";
  }
  out_file << "#include <nlohmann/json.hpp>\n\n"; // Use quotes for consistency

  out_file << "namespace " << cpp_namespace << " {\n\n";

  out_file << kind << " " << struct_name;
  if (is_final)
    out_file << " final";
  out_file << build_inheritance_string(meta_schema) << " {\n";

  if (kind == "class")
    out_file << "public:\n";
  if (meta_schema.contains(
          "generate_constructor")) { /* ... constructor logic ... */
  }
  out_file << "\n    // Member Variables\n";
  for (auto &[name, type] : meta_schema.at("schema").items()) {
    out_file << "    " << type.get<std::string>() << " " << name << ";\n";
  }
  if (meta_schema.contains("methods")) { /* ... method logic ... */
  }
  out_file << "};\n\n";

  // --- JSON Serialization ---

  // **FIXED SECTION**

  // Generate to_json function
  out_file << "// JSON Serialization (to JSON)\n";
  out_file << "inline void to_json(nlohmann::json& j, const " << struct_name
           << "& obj) {\n";
  for (auto &[name, type] : meta_schema.at("schema").items()) {
    out_file << "    j[\"" << name << "\"] = obj." << name << ";\n";
  }
  out_file << "}\n\n";

  // Generate from_json function
  out_file << "// JSON Deserialization (from JSON)\n";
  out_file << "inline void from_json(const nlohmann::json& j, " << struct_name
           << "& obj) {\n";
  for (auto &[name, type_json] : meta_schema.at("schema").items()) {
    std::string type_str = type_json.get<std::string>();
    out_file << "    obj." << name << " = j.value(\"" << name << "\", "
             << get_default_value(type_str) << ");\n";
  }
  out_file << "}\n\n";

  out_file << "} // namespace " << cpp_namespace << "\n";

  std::cout << "Successfully generated " << output_path << " from "
            << input_path << std::endl;

  return 0;
}
