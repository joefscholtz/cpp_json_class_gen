#include "nlohmann/json.hpp"
#include <fstream>
#include <iostream>
#include <set>
#include <string>
#include <vector>

class JsonClassGenerator {
public:
  JsonClassGenerator(std::ofstream &out_file) : out_file_(out_file) {}

  void process(const nlohmann::json &root_schema) {
    out_file_ << "// AUTOGENERATED FILE - DO NOT EDIT\n\n";
    out_file_ << "#pragma once\n\n";

    for (const auto &header : root_schema.at("include_headers")) {
      out_file_ << "#include \"" << header.get<std::string>() << "\"\n";
    }
    out_file_ << "#include <nlohmann/json.hpp>\n\n";

    std::string root_namespace = root_schema.value("cpp_namespace", "");
    if (!root_namespace.empty()) {
      out_file_ << "namespace " << root_namespace << " {\n\n";
    }

    generate_struct_from_schema(root_schema, root_namespace);

    if (!root_namespace.empty()) {
      out_file_ << "} // namespace " << root_namespace << "\n";
    }
  }

private:
  std::ofstream &out_file_;
  std::set<std::string> generated_types_;

  std::string get_default_value(const std::string &cpp_type) {
    if (cpp_type == "std::string")
      return "\"\"";
    if (cpp_type == "int" || cpp_type == "uint64_t")
      return "0";
    if (cpp_type == "bool")
      return "false";

    // Check for containers and custom types
    size_t colon_pos = cpp_type.find("::");
    if (colon_pos != std::string::npos) {
      // It's a custom type (e.g., gcal::ApiEvent or
      // std::vector<gcal::ApiEvent>) We can just return the type with an empty
      // initializer list.
      return cpp_type + "{}";
    }

    // Fallback for simple custom types without a namespace prefix
    if (cpp_type.rfind("std::", 0) != 0) {
      return cpp_type + "{}";
    }

    return "{}";
  }

  std::string build_inheritance_string(const nlohmann::json &schema) {
    // Check if the key exists and is an array. If not, return an empty string.
    if (!schema.contains("base_classes") ||
        !schema["base_classes"].is_array()) {
      return "";
    }

    std::string inheritance_str = " : ";
    bool is_first = true;

    for (const auto &base : schema["base_classes"]) {
      if (!is_first) {
        inheritance_str += ", ";
      }
      // Prepend "public" to each base class for public inheritance.
      inheritance_str += "public " + base.get<std::string>();
      is_first = false;
    }

    return inheritance_str;
  }

  // The main recursive method
  void generate_struct_from_schema(const nlohmann::json &schema,
                                   const std::string &current_namespace) {
    std::string struct_name;
    try {
      struct_name = schema.at("struct_name").get<std::string>();
    } catch (const nlohmann::json::exception &e) {
      std::cerr << "Schema error: 'struct_name' is missing or not a string.\n"
                << e.what() << std::endl;
      throw;
    }

    if (generated_types_.count(struct_name))
      return;

    // Recursively generate any nested types first
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        if (definition.is_object() && definition.contains("schema")) {
          // Nested types are generated in the same namespace as their parent.
          generate_struct_from_schema(definition.at("schema"),
                                      current_namespace);
        }
      }
    }

    // Generate definition.
    std::string kind = schema.value("kind", "struct");
    bool is_final = schema.value("is_final", false);

    out_file_ << kind << " " << struct_name;
    if (is_final)
      out_file_ << " final";

    out_file_ << build_inheritance_string(schema) << " {\n";

    if (kind == "class")
      out_file_ << "public:\n";

    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        std::string type_str;
        if (definition.is_object()) {
          type_str = definition.at("type").get<std::string>();
        } else {
          type_str = definition.get<std::string>();
        }
        out_file_ << "    " << type_str << " " << name << ";\n";
      }
    }
    out_file_ << "};\n\n";

    // Serialization
    out_file_ << "// JSON Serialization for " << struct_name << "\n";
    out_file_ << "inline void to_json(nlohmann::json& j, const " << struct_name
              << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        out_file_ << "    j[\"" << name << "\"] = obj." << name << ";\n";
      }
    }
    out_file_ << "}\n\n";

    // Deserialization
    out_file_ << "inline void from_json(const nlohmann::json& j, "
              << struct_name << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        std::string type_str;
        if (definition.is_object()) {
          type_str = definition.at("type").get<std::string>();
        } else {
          type_str = definition.get<std::string>();
        }

        // Checks if the key exists and is not null before converting.
        out_file_ << "    if (j.contains(\"" << name << "\") && !j.at(\""
                  << name << "\").is_null()) {\n";
        out_file_ << "        j.at(\"" << name << "\").get_to(obj." << name
                  << ");\n";
        out_file_ << "    } else {\n";
        out_file_ << "        obj." << name << " = "
                  << get_default_value(type_str) << ";\n";
        out_file_ << "    }\n";
      }
    }
    out_file_ << "}\n\n";

    generated_types_.insert(struct_name);
  }
};

int main(int argc, char *argv[]) {
  if (argc != 3) {
    std::cerr << "Usage: " << argv[0] << " <input_json> <output_header>"
              << std::endl;
    return 1;
  }
  std::string input_path = argv[1];
  std::string output_path = argv[2];

  try {
    std::ifstream input_file(input_path);
    if (!input_file.is_open()) {
      std::cerr << "Error: Could not open input file " << input_path
                << std::endl;
      return 1;
    }
    nlohmann::json root_schema;
    input_file >> root_schema;
    std::ofstream out_file(output_path);
    JsonClassGenerator generator(out_file);
    generator.process(root_schema);
    std::cout << "Successfully generated " << output_path << " from "
              << input_path << std::endl;
  } catch (const std::exception &e) {
    std::cerr << "A fatal error occurred while processing '" << input_path
              << "':\n"
              << e.what() << std::endl;
    return 1;
  }

  return 0;
}
