#include "nlohmann/json.hpp"
#include <fstream>
#include <iostream>
#include <set>
#include <string>
#include <vector>

class JsonClassGenerator {
public:
  JsonClassGenerator(std::ofstream &out_file) : out_file_(out_file) {}

  void process(const nlohmann::json &root_schema) {
    out_file_ << "// AUTOGENERATED FILE - DO NOT EDIT\n\n";
    out_file_ << "#pragma once\n\n";

    for (const auto &header : root_schema.at("include_headers")) {
      out_file_ << "#include <" << header.get<std::string>() << ">\n";
    }
    out_file_ << "#include <nlohmann/json.hpp>\n\n";

    generate_struct_from_schema(root_schema,
                                root_schema.value("cpp_namespace", ""));
  }

private:
  std::ofstream &out_file_;
  std::set<std::string> generated_types_;

  std::string get_default_value(const std::string &cpp_type) {
    if (cpp_type == "std::string")
      return "\"\"";
    if (cpp_type == "int" || cpp_type == "uint64_t")
      return "0";
    if (cpp_type == "bool")
      return "false";
    if (cpp_type.rfind("std::vector", 0) == 0)
      return cpp_type + "{}";
    return "{}";
  }

  void generate_struct_from_schema(const nlohmann::json &schema,
                                   const std::string &default_namespace) {
    std::string struct_name = schema.at("struct_name").get<std::string>();
    if (generated_types_.count(struct_name))
      return;

    // 1. Recursively generate any nested types FIRST.
    if (schema.contains("schema")) {
      for (const auto &field_def : schema.at("schema").items()) {
        if (field_def.value().contains("schema")) {
          std::string nested_ns =
              field_def.value().value("cpp_namespace", default_namespace);
          generate_struct_from_schema(field_def.value().at("schema"),
                                      nested_ns);
        }
      }
    }

    // 2. Generate the current struct.
    std::string kind = schema.value("kind", "struct");
    std::string cpp_namespace =
        schema.value("cpp_namespace", default_namespace);

    out_file_ << "namespace " << cpp_namespace << " {\n\n";
    out_file_ << kind << " " << struct_name << " {\n";
    if (kind == "class")
      out_file_ << "public:\n";

    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        out_file_ << "    " << definition.at("type").get<std::string>() << " "
                  << name << ";\n";
      }
    }
    out_file_ << "};\n\n";

    // Generate JSON serialization functions
    out_file_ << "inline void to_json(nlohmann::json& j, const " << struct_name
              << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        out_file_ << "    j[\"" << name << "\"] = obj." << name << ";\n";
      }
    }
    out_file_ << "}\n\n";

    out_file_ << "inline void from_json(const nlohmann::json& j, "
              << struct_name << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        std::string type_str = definition.at("type").get<std::string>();
        out_file_ << "    obj." << name << " = j.value(\"" << name << "\", "
                  << get_default_value(type_str) << ");\n";
      }
    }
    out_file_ << "}\n\n";

    out_file_ << "} // namespace " << cpp_namespace << "\n\n";

    generated_types_.insert(struct_name);
  }
};

int main(int argc, char *argv[]) {
  if (argc != 3) {
    std::cerr << "Usage: " << argv[0] << " <input_json> <output_header>"
              << std::endl;
    return 1;
  }
  std::string input_path = argv[1];
  std::string output_path = argv[2];

  std::ifstream input_file(input_path);
  nlohmann::json root_schema;
  input_file >> root_schema;

  std::ofstream out_file(output_path);

  JsonClassGenerator generator(out_file);
  generator.process(root_schema);

  std::cout << "Successfully generated " << output_path << " from "
            << input_path << std::endl;
  return 0;
}
