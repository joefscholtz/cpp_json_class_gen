#include "nlohmann/json.hpp"
#include <fstream>
#include <iostream>
#include <set>
#include <string>
#include <vector>

class JsonClassGenerator {
public:
  JsonClassGenerator(std::ofstream &out_file) : out_file_(out_file) {}

  void process(const nlohmann::json &root_schema) {
    out_file_ << "// AUTOGENERATED FILE - DO NOT EDIT\n\n";
    out_file_ << "#pragma once\n\n";

    // This can throw if "include_headers" is missing or not an array
    for (const auto &header : root_schema.at("include_headers")) {
      out_file_ << "#include <" << header.get<std::string>() << ">\n";
    }
    out_file_ << "#include <nlohmann/json.hpp>\n\n";

    generate_struct_from_schema(root_schema,
                                root_schema.value("cpp_namespace", ""));
  }

private:
  std::ofstream &out_file_;
  std::set<std::string> generated_types_;

  std::string get_default_value(const std::string &cpp_type) {
    if (cpp_type == "std::string")
      return "\"\"";
    if (cpp_type == "int" || cpp_type == "uint64_t")
      return "0";
    if (cpp_type == "bool")
      return "false";
    if (cpp_type.rfind("std::vector", 0) == 0)
      return cpp_type + "{}";
    return "{}";
  }

  void generate_struct_from_schema(const nlohmann::json &schema,
                                   const std::string &default_namespace) {
    // Use a try-catch block for keys that are absolutely required.
    std::string struct_name;
    try {
      struct_name = schema.at("struct_name").get<std::string>();
    } catch (const nlohmann::json::exception &e) {
      std::cerr << "Schema error: 'struct_name' is missing or not a string.\n"
                << e.what() << std::endl;
      throw; // Re-throw to stop the generation process
    }

    if (generated_types_.count(struct_name))
      return;

    // --- Recursive Generation ---
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        if (definition.is_object() && definition.contains("schema")) {
          std::string nested_ns =
              definition.value("cpp_namespace", default_namespace);
          generate_struct_from_schema(definition.at("schema"), nested_ns);
        }
      }
    }

    // --- Current Struct Generation ---
    std::string kind = schema.value("kind", "struct");
    std::string cpp_namespace =
        schema.value("cpp_namespace", default_namespace);

    out_file_ << "namespace " << cpp_namespace << " {\n\n";
    out_file_ << kind << " " << struct_name << " {\n";
    if (kind == "class")
      out_file_ << "public:\n";

    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        // This is the critical section that was failing.
        try {
          out_file_ << "    " << definition.at("type").get<std::string>() << " "
                    << name << ";\n";
        } catch (const nlohmann::json::exception &e) {
          std::cerr << "\nERROR processing schema for struct '" << struct_name
                    << "':\n";
          std::cerr << "Field '" << name
                    << "' is malformed. Expected a JSON object with a 'type' "
                       "key, but got: "
                    << definition.dump() << "\n";
          std::cerr << "JSON library error: " << e.what() << "\n" << std::endl;
          throw; // Stop generation
        }
      }
    }
    out_file_ << "};\n\n";

    // --- Serialization ---
    out_file_ << "inline void to_json(nlohmann::json& j, const " << struct_name
              << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        out_file_ << "    j[\"" << name << "\"] = obj." << name << ";\n";
      }
    }
    out_file_ << "}\n\n";

    out_file_ << "inline void from_json(const nlohmann::json& j, "
              << struct_name << "& obj) {\n";
    if (schema.contains("schema")) {
      for (auto &[name, definition] : schema.at("schema").items()) {
        std::string type_str = definition.at("type").get<std::string>();
        out_file_ << "    obj." << name << " = j.value(\"" << name << "\", "
                  << get_default_value(type_str) << ");\n";
      }
    }
    out_file_ << "}\n\n";

    out_file_ << "} // namespace " << cpp_namespace << "\n\n";
    generated_types_.insert(struct_name);
  }
};

int main(int argc, char *argv[]) {
  if (argc != 3) {
    std::cerr << "Usage: " << argv[0] << " <input_json> <output_header>"
              << std::endl;
    return 1;
  }
  std::string input_path = argv[1];
  std::string output_path = argv[2];

  // Wrap the entire process in a try-catch block for robust error handling
  try {
    std::ifstream input_file(input_path);
    if (!input_file.is_open()) {
      std::cerr << "Error: Could not open input file " << input_path
                << std::endl;
      return 1;
    }

    nlohmann::json root_schema;
    input_file >> root_schema;

    std::ofstream out_file(output_path);

    JsonClassGenerator generator(out_file);
    generator.process(root_schema);

    std::cout << "Successfully generated " << output_path << " from "
              << input_path << std::endl;
  } catch (const nlohmann::json::exception &e) {
    std::cerr << "A fatal JSON error occurred while processing '" << input_path
              << "':\n"
              << e.what() << std::endl;
    return 1; // Return an error code to fail the build
  } catch (const std::exception &e) {
    std::cerr << "A fatal error occurred while processing '" << input_path
              << "':\n"
              << e.what() << std::endl;
    return 1; // Return an error code to fail the build
  }

  return 0;
}
