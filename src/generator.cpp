#include "nlohmann/json.hpp"
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

std::string build_inheritance_string(const nlohmann::json &meta_schema) {
  if (!meta_schema.contains("base_classes")) {
    return "";
  }
  std::string inheritance_str = " : ";
  bool first = true;
  for (const auto &base : meta_schema["base_classes"]) {
    if (!first) {
      inheritance_str += ", ";
    }
    inheritance_str += "public " + base.get<std::string>();
    first = false;
  }
  return inheritance_str;
}

std::string get_default_value(const std::string &cpp_type) {
  if (cpp_type == "std::string") {
    return "\"\"";
  }
  if (cpp_type == "int" || cpp_type == "uint64_t") {
    return "0";
  }
  if (cpp_type == "bool") {
    return "false";
  }
  // For complex types like std::vector, return an empty initializer
  if (cpp_type.rfind("std::vector", 0) == 0) {
    return "{}";
  }
  return "{}"; // Default for unknown types
}

int main(int argc, char *argv[]) {
  if (argc != 3) {
    std::cerr << "Usage: " << argv[0] << " <input_json> <output_header>"
              << std::endl;
    return 1;
  }

  std::string input_path = argv[1];
  std::string output_path = argv[2];

  std::ifstream input_file(input_path);
  if (!input_file.is_open()) {
    std::cerr << "Error: Could not open input file " << input_path << std::endl;
    return 1;
  }

  nlohmann::json meta_schema;
  input_file >> meta_schema;

  std::string kind = meta_schema.value("kind", "struct");
  std::string struct_name = meta_schema.at("struct_name").get<std::string>();
  std::string cpp_namespace =
      meta_schema.at("cpp_namespace").get<std::string>();
  bool is_final = meta_schema.value("is_final", false);

  std::ofstream out_file(output_path);

  // --- Start File Generation ---
  out_file << "// AUTOGENERATED FILE - DO NOT EDIT\n\n";
  out_file << "#pragma once\n\n";

  for (const auto &header : meta_schema.at("include_headers")) {
    out_file << "#include <" << header.get<std::string>() << ">\n";
  }
  out_file << "#include \"nlohmann/json.hpp\"\n\n";

  out_file << "namespace " << cpp_namespace << " {\n\n";

  // --- Class/Struct Definition Line ---
  out_file << kind << " " << struct_name;
  if (is_final) {
    out_file << " final";
  }
  out_file << build_inheritance_string(meta_schema) << " {\n";

  if (kind == "class") {
    out_file << "public:\n";
  }

  // --- Constructors ---
  if (meta_schema.contains("generate_constructor")) {
    std::string ctor_type = meta_schema["generate_constructor"];
    if (ctor_type == "default" || ctor_type == "default_and_members") {
      out_file << "    " << struct_name << "() = default;\n";
    }
    // TODO: Add logic for member-wise constructor if needed
  }

  // --- Member Variables ---
  out_file << "\n    // Member Variables\n";
  for (auto &[name, type] : meta_schema.at("schema").items()) {
    out_file << "    " << type.get<std::string>() << " " << name << ";\n";
  }

  // --- Custom Method Declarations ---
  if (meta_schema.contains("methods")) {
    out_file << "\n    // Custom Method Declarations\n";
    for (const auto &method : meta_schema["methods"]) {
      out_file << "    " << method.get<std::string>() << ";\n";
    }
  }

  out_file << "};\n\n";

  // --- JSON Serialization ---
  out_file << "// JSON Serialization Functions\n";
  out_file << "inline void from_json(const nlohmann::json& j, " << struct_name
           << "& obj) {\n";
  for (auto &[name, type_json] : meta_schema.at("schema").items()) {
    std::string type_str = type_json.get<std::string>();
    // Use .value() to safely get the key or a default value
    out_file << "    obj." << name << " = j.value(\"" << name << "\", "
             << get_default_value(type_str) << ");\n";
  }
  out_file << "}\n\n";

  out_file << "inline void from_json(const nlohmann::json& j, " << struct_name
           << "& obj) {\n";
  for (auto &[name, type] : meta_schema.at("schema").items()) {
    out_file << "    j.at(\"" << name << "\").get_to(obj." << name << ");\n";
  }
  out_file << "}\n\n";

  out_file << "} // namespace " << cpp_namespace << "\n";

  std::cout << "Successfully generated " << output_path << " from "
            << input_path << std::endl;

  return 0;
}
